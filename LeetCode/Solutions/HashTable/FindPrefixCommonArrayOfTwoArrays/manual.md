## Success

### Вариант 1

```csharp
public class Solution
{
    public int[] FindThePrefixCommonArray(int[] A, int[] B)
    {
        var result = new int[A.Length];
        var map = new bool[A.Length + 1];
        var counter = 0;

        for (int i = 0; i < result.Length; i++)
        {
            if (map[A[i]])
                counter++;
            else
                map[A[i]] = true;

            if (map[B[i]])
                counter++;
            else
                map[B[i]] = true;

            result[i] = counter;
        }

        return result;
    }
}
```

***Оценка по времени:*** O(n)

Так как проходимся один раз по всему массиву `result`, у которого размер идентичен с размерами массивов `A` и `B`.

***Оценка по памяти:*** O(n)

Запоминаем уже пройденные значения в массиве `map`.

**Описание решения**

Создаем сразу результат, размером как массивы `A` и `B`, массив для запоминания пройденных значений, размером как массивы `A` и `B`, так как это максимальное возможное число, и глобальный счетчик. Далее проходимся по массиву результата, а также по `A` и `B` тем же указателем, запоминаем все пройденные значения. Если в общем массиве такое значение мы уже проходили, то увеличиваем счетчик. И в индекс результата записываем счетчик на момент итерации. Суть задачи - посчитать количество равных значений в массивах `A` и `B` от индекса `0` до индекса `i` на каждой итерации, увеличивая на каждом шаге индекс `i`.

### Вариант 2 (оптимальное решение)

```csharp
public class Solution
{
    public int[] FindThePrefixCommonArray(int[] A, int[] B)
    {
        var result = new int[A.Length];
        ulong maskA = 0, maskB = 0;

        for (int i = 0; i < result.Length; i++)
        {
            maskA |= 1ul << A[i];
            maskB |= 1ul << B[i];
            result[i] = BitOperations.PopCount(maskA & maskB);
        }

        return result;
    }
}
```

***Оценка по времени:*** O(n)

***Оценка по памяти:*** O(1)

Так как не используем вспомогательный массив для запоминания пройденных значений, а используем маску типа `ulong`. Если учитывать массив для ответа `result`, тогда будет `O(n)`.

**Описание решения**

Вместо использования вспомогательного массива используем 64-битные маску (так как значения ограничены **от 1 до 50**) для пересечения элементов `A` и `B`. Опетратор `<<` сдвиг влево на нули, количество которых определяет значение из массива. Метод `BitOperations.PopCount` + `maskA & maskB` определяет пересечение между масками и возвращает количество единиц (бит). Данное кол-во единиц и является ответом на каждой итерации.