## Success

```csharp
public class Solution
{
    public TreeNode SortedArrayToBST(int[] nums)
    {
        return CreateTreeNodeFromSortedArray(nums, 0, nums.Length - 1)!;
    }
    
    private static TreeNode? CreateTreeNodeFromSortedArray(int[] nums, int left, int right)
    {
        if (left > right)
            return null;

        var mid = (left + right) / 2;

        return new TreeNode
        {
            val = nums[mid],
            left = CreateTreeNodeFromSortedArray(nums, left, mid - 1),
            right = CreateTreeNodeFromSortedArray(nums, mid + 1, right)
        };
    }
}
```

***Оценка по времени:*** O(n)

Делаем проход по массиву при участии двух указателей "С двух сторон", создавая вершину поддерева.

***Оценка по памяти:*** O(log n) или O(h)

Использование рекурсии накладывает дополнительные ресурсы на память, такие как: локальные переменные, аргументы функции и адрес возврата (куда вернуться после завершения вызова). Поэтому в данном случае будет `O(h)` по памяти, где `h` - кол-во ребер дерева в глубину. Но так как заранее мы не знаем, сколько таких ребер, можно утвердить, что время по памяти составляет `O(log n)` по причине, что это сбалансированное дерево и массив делится пополам с каждым заходом в рекурсию, разделяясь на левое и правое поддеревья.

**Описание решения**

Начинаем с обнаружения корня дерева через использование двух указателей с двух сторон. Далее для определения левого и правого поддеревьев мы смещаем указатели: идем влево - смещаем правый указатель, идем вправо - смещаем левый указатель. Смещение зависит от индекса родителя. Ответ возвращаем обратно вверх к родителю.