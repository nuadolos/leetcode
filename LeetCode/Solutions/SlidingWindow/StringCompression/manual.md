## Success

```csharp
public class Solution
{
    public int Compress(char[] chars)
    {
        int l = 0, r = 0, slow = 0;
        while (l < chars.Length)
        {
            while (r + 1 < chars.Length && chars[r] == chars[r + 1])
                r++;
            
            chars[slow++] = chars[l];
                
            if (l != r)
            {
                var count = r - l + 1;
                foreach (var c in count.ToString())
                    chars[slow++] = c;
            }
            
            l = ++r;    
        }
        
        return slow;
    }
}
```

***Оценка по времени:*** O(n)

***Оценка по памяти:*** O(1)

**Описание решения**

Итерируемся по массиву относительно левого указателя. Также имеем дополнительный указатель `slow` для записи результатов в массив из параметров, а также в качестве размера результирующего массива (так как на каждой новой итерации `slow` будет за пределами результата, то есть для записи следующего символа). Далее ищем при вычислении правого указателя границу между разными символами. В начало записываем этот символ, а далее, если левый и правый указатели не равны друг другу, записываем количество идущих подряд тех же самых символов. Также указатель `slow` никогда не выйдет за границу массива `chars`, потому что:
- если встретим лишь один символ, то его мы и запишем в результат.
- если встретим два символа, то запишем также 2 символа в результат: сам символ + '2'.
- если встретим больше двух символов, то у нас останется даже пустое место. Например, 12 символов - результат будет сам символ + '1' + '2', то есть всего 3 символа.